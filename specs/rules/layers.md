# Архитектурные границы

TODO: переработать

Основная цель слоистых архитектур - отделить бизнес-логику от фреймворков, инфраструктуры и интерфейсов ввода/вывода.

Инфраструктура - это подключение к базе данных, ORM, обращение к внешнему сервису, шина сообщений, отправка
уведомлений, сбор метрик и т.д.

Главное правило - бизнес-логика не должна зависеть от деталей реализации и быть подальше от побочных эффектов.
Для этого нужно соблюдать правило инверсии зависимостей,
нижележащие слои не могут зависеть от вышестоящих.

Конкретно в Python это означает, что в слой бизнес-логики не должно быть импортов
из слоя инфраструктуры и ввода/вывода.
Чтобы обозначить ожидаемый интерфейс объектов из слоя инфраструктуры в аннотациях типов, не импортируя их,
можно создавать заглушки объектов наследуясь от класса `Protocol`.
Пример в [interfaces.py](project/components/chat/interfaces.py)

Из-за того, что бизнес-логика не зависит от деталей реализации, упрощается тестирование.
Пример теста бизнес-логики посмотрите тут [test_ask.py](tests/test_domains/test_chat/test_ask.py)

Пример, как надо писать модули смотрите на примере домена [chat](project/components/chat)

## Слои

Считаю, что абстракции UseCase, Service, Repository
могут быть достаточными для скрытия сложности на ранней стадии проекта.
Вводить новые сущности можно по мере увеличения сложности проекта.
Поэтому ограничимся описанием этих паттернов.

**UseCase** - точка входа в бизнес-сценарии. Пример [use_cases.py](project/components/chat/use_cases.py).
Слой, через который интерфейсы ввода/вывода запускают бизнес-логику.
Здесь содержится валидация данных, авторизация, проверка квоты, лимитов и т.д.
Поэтому другие домены и поддомены бизнес-логики не должны использовать `UseCase`.
Реализация бизнес-процессов должна находится в `Service`-ах.
В `UseCase` не должно быть того, что потребуется в `Service`-ах в других доменах и поддоменах.
Имя сценария должно отражать бизнес-функцию.
Ожидается, что `UseCase` должен быть очень простым (мало строк) и понятным для чтения.
Сам код, нейминг классов и методов должен описывать, что происходит в терминах бизнеса -
провалидировать данные, проверить авторизацию, квоту, запустить бизнес-процесс.
Валидацию данных лучше использовать на этом слое,
но детали реализации (функции валидаций) выносить в модуль `validation.py`

`UseCase` - это объект без состояния.

**Service** - скрывает детали реализации бизнес-процесса. Пример [service.py](project/components/chat/service.py)
Может объединять в себе работу одного или нескольких доменов.\
Объект без состояния.

**Repository** - нужны, чтобы отделить доступ к данным от ORM. Пример [repositories.py]
(project/components/chat/repositories.py)\
Объект без состояния.

- доступ к данным изолируйте в классах Repository, в бизнес-логике извлечение данных из бд затрудняет 
  читать и понимать саму бизнес-логику. Ищите примеры в модулях [repositories.py](project/components/user/repositories.py)
- Есть generic базовый класс с базовыми методами, наследуйте ваши Repository от него, пример в [repositories.py](project/components/user/repositories.py)

```python
# Когда мы смотрим на бизнес-логику, лучше увидеть такое
UserRepo.get_users(user_ids=[1, 2, 3])
# чем такое
query = select(User).where(User.id.in_([1, 2, 3]))
async with Session() as session:
    result = session.execute(query)
    data = await result.scalars().all()
```

**Interface** - это объект, показывающий ожидаемый интерфейс, используется только в аннотациях типов.
Пример [interfaces.py](project/components/chat/interfaces.py).
Избавляет от необходимости импорта реального объекта,
чтобы не нарушать правило инверсии зависимостей.

**Adapter** - реализация интерфейса. Пример [llm.py](project/infrastructure/adapters/llm.py).
Чтобы не зависеть от конкретных фреймворков и других зависимостей,
мы взаимодействуем с ними через фасад.
Благодаря этому можно заменить технологию, находящуюся за фасадом.

**DIContainer** - контейнер, в котором разрешаются зависимости, создается один раз.
Пример [container.py](project/container.py).
Знает кому, какие зависимости нужны и откуда их взять.
Избавляет нас от необходимости думать, как создать объект.
Если нужно в одной **транзакции** изменить несколько моделей, т.е. вне границ репозитория домена,
лучше создайте еще один репозиторий для этого.

## Линтер слоев
Есть линтер, который проверяет направление зависимостей, настроенных в конфиге [layers.toml](../../layers.toml).
Запускается через 
```bash
layers-linter project
```

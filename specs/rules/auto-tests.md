
# Автотесты
- Как запускать тесты написанно в [README.md](../../README.md)
- Фикстуры в [conftest.py](tests/conftest.py).
- При запуске тестов автоматически поднимаются контейнеры с базами данных через testconteiners (на время тестов)
- Уровень логирование в тестах настраивается в [pytest.ini](pytest.ini)

Пример теста эндпоинта API [test_endpoints.py](tests/test_domains/test_chat/test_endpoints.py).

##  Антипаттерны в тестах
- абстракции для тестов, это последнее, во что хочется вникать, максимально избегайте их. Идеально, когда всё, что 
  относится к данному тесту, находится внутри него, без необходимости прыгать по модулям, чтоб понять, как он 
  работает.
- данные для теста в фикстурах затрудяет чтение теста, добавление и изменение данных. Данные 
  должны быть внутри теста, несмотря на то, что данные могут дублироваться между тестами.
- большое кол-во assert в тесте это плохо, скорее всего в тамком тесте проверяется много кейсов, наилучший вариант, 
  в одном тесте проверять что-то одно
- не пишите юнит-тесты, потому что при рефакторинге приходится изменять тесты, а этим ни кто не хочет 
  заниматься, поэтому будет затруднять рефакторинг. Тестируйте поведение программы. Тестируйте сверху, через UseCase 
  или эндпоинты. Пишите функциональные тесты.
- запрещено использовать unittest.mock.patch, если он вам понадобился, значит реализация спроектирована неверно, 
  перепишите код, следуя принципу dependency inversion. Подмените реализацию объекта, передав мок объект с другим 
  поведением (заглушку) в конструктор или через аргументы функции.
- проверяйте в тестах поведение программы, а не объекты

## Как создавать данные для теста

В проекте есть фабрики объектов ORM моделей, они позволяют подготавливать окружение для тестирования.
Находятся в [factories.py](tests/factories.py).
Пример использования в [test_use_case.py](../../tests/test_domains/test_chat/test_use_case.py).

В тестах используется одна сессия SqlAlchemy с БД без завершения транзакции, поэтому объекты на самом деле не создаются 
фабрикой в БД, но благодаря внутреннему хранилищу ORM, программа видит эти объекты.

Где обычно создают данные для теста? В фикстурах.
Потом их использует и в других тестах.
Чтоб создать немного другие данные, создает еще фикстуру и так проект ими зарастает.

Фабрики позволяют создавать объекты с разными параметрами, что делает их более гибкими.
Одна фабрика для создания объектов с разными настройками.
Полезно, когда вам нужно создавать объекты с разными состояниями в тестах.

Фабрики позволяют изолировать данные тестов друг от друга, так как каждый тест может создавать свои собственные объекты.

Фабрики упрощают поддержку кода, так как логика создания объектов сосредоточена в одном месте.
Если вам нужно изменить способ создания объекта, вы делаете это только в фабрике, а не в каждом тесте.

Фикстуры в `pytest` могут быть "магическими" — они автоматически подставляются в тесты,
что может затруднить понимание того, что именно происходит.
Фабрики, явно вызываются в коде, улучшая понимание теста.

Фабрики лучше подходят для сложных сценариев,
где нужно создавать объекты с множеством зависимостей или выполнять дополнительные действия при создании.
Фикстуры могут стать громоздкими в таких случаях.

## Описание фикстур в conftest.py

### Фикстуры настройки окружения

**`setup`** (scope="session", autouse=True)
- Автоматически применяется ко всем тестам
- Устанавливает тестовое окружение (ENV="AUTOTESTS", токены, ключи)
- Настраивает логирование

### Фикстуры для работы с базой данных

**`init_database`** (scope="session")
- Поднимает PostgreSQL контейнер через testcontainers
- Создает схему БД
- Возвращает engine для подключения
- Автоматически очищается после всех тестов

**`session`**
- Создает синхронную сессию SQLAlchemy для теста
- Все изменения откатываются после теста (rollback)
- БД всегда остается чистой между тестами

Пример использования:
```python
def test_create_user(session):
    # После теста данные автоматически откатятся
    ...
```

**`asession`**
- Асинхронная версия `session`

Пример использования:
```python
async def test_create_user_async(asession):
    # После теста данные автоматически откатятся
    ...
```

### Фикстуры для работы с Redis

**`init_redis`** (scope="session")
- Поднимает Redis контейнер
- Возвращает синхронный клиент Redis

**`redis`**
- Синхронный Redis клиент для теста
- Автоматически очищает базу после теста (flushdb)

Пример использования:
```python
def test_cache(redis):
    # После теста Redis очищается
    ...
```

**`async_init_redis`** (scope="session")
- Асинхронная версия Redis контейнера

**`async_redis`**
- Асинхронный Redis клиент
- Очищается после теста

Пример использования:
```python
async def test_cache_async(async_redis):
    # После теста Redis очищается
    ...
```

### Фикстуры для тестирования API

**`api_client`**
- TestClient для тестирования FastAPI эндпоинтов
- Автоматически добавляет API токен в заголовки

Пример использования:
```python
def test_endpoint(api_client):
    response = api_client.get("/api/users")
    assert response.status_code == 200
    assert response.json() == []
```

### Фикстуры для мокирования HTTP запросов

**`httpx_responses`**
- Для мокирования синхронных HTTP запросов (httpx)
- Использует библиотеку respx

Пример использования:
```python
def test_external_api(httpx_responses):
    httpx_responses.add(
        "GET",
        "https://api.example.com/data",
        json={"result": "success"},
        status=200
    )
    # Теперь запросы на этот URL вернут mock-ответ
```

**`aiohttp_responses`**
- Для мокирования асинхронных HTTP запросов (aiohttp)
- Использует библиотеку aioresponses

Пример использования:
```python
async def test_external_api_async(aiohttp_responses):
    aiohttp_responses.add(
        "https://api.example.com/data",
        method="GET",
        payload={"result": "success"},
        status=200
    )
    # Асинхронные запросы на этот URL вернут mock-ответ
```

### Фикстуры для работы с Keycloak

**`keycloak_client`**
- Синхронный клиент Keycloak с тестовыми настройками
- Для тестирования интеграции с Keycloak

**`mock_keycloak`**
- Мокирует ответы Keycloak для синхронных запросов
- Возвращает тестовый токен

Пример использования:
```python
def test_keycloak_auth(keycloak_client, mock_keycloak):
    # mock_keycloak автоматически мокирует запросы
    token = keycloak_client.get_token()
    assert token == "test_token"
```

**`keycloak_aclient`**
- Асинхронный клиент Keycloak

**`mock_async_keycloak`**
- Мокирует асинхронные запросы к Keycloak

### Вспомогательные фикстуры

**`project_dir`** (scope="session")
- Возвращает путь к директории проекта
- Полезно для работы с файлами проекта в тестах

Пример использования:
```python
def test_config_file(project_dir):
    config_path = project_dir / "config.yaml"
    assert config_path.exists()
```
